<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <pre>
        struct TreeNode {
            int data;
            struct TreeNode* left;
            struct TreeNode* right;
        };
        
        struct TreeNode* insert(struct TreeNode* root, int value);
        struct TreeNode* deleteNode(struct TreeNode* root, int key);
        struct TreeNode* search(struct TreeNode* root, int key);
        void preorder(struct TreeNode* root);
        void inorder(struct TreeNode* root);
        void postorder(struct TreeNode* root);
        struct TreeNode* findMin(struct TreeNode* root);
        
        int main() {
            struct TreeNode* root = NULL;
            int choice, value, key;
        
            do {
                printf("\nBinary Search Tree Operations\n");
                printf("1. Insert\n");
                printf("2. Delete\n");
                printf("3. Search\n");
                printf("4. Preorder Traversal\n");
                printf("5. Inorder Traversal\n");
                printf("6. Postorder Traversal\n");
                printf("7. Find Minimum Element\n");
                printf("8. Exit\n");
                printf("Enter your choice: ");
                scanf("%d", &choice);
        
                switch (choice) {
                    case 1:
                        printf("Enter the value to insert: ");
                        scanf("%d", &value);
                        root = insert(root, value);
                        break;
                    case 2:
                        printf("Enter the key to delete: ");
                        scanf("%d", &key);
                        root = deleteNode(root, key);
                        break;
                    case 3:
                        printf("Enter the key to search: ");
                        scanf("%d", &key);
                        if (search(root, key) != NULL)
                            printf("%d is present in the tree.\n", key);
                        else
                            printf("%d is not present in the tree.\n", key);
                        break;
                    case 4:
                        printf("Preorder Traversal: ");
                        preorder(root);
                        printf("\n");
                        break;
                    case 5:
                        printf("Inorder Traversal: ");
                        inorder(root);
                        printf("\n");
                        break;
                    case 6:
                        printf("Postorder Traversal: ");
                        postorder(root);
                        printf("\n");
                        break;
                    case 7:
                        if (root != NULL) {
                            struct TreeNode* minNode = findMin(root);
                            printf("Minimum Element: %d\n", minNode->data);
                        } else {
                            printf("Tree is empty.\n");
                        }
                        break;
                    case 8:
                        printf("Exiting the program.\n");
                        break;
                    default:
                        printf("Invalid choice. Please enter a valid option.\n");
                }
        
            } while (choice != 8);
        
            return 0;
        }
        
        struct TreeNode* insert(struct TreeNode* root, int value) {
            if (root == NULL) {
                struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));
                newNode->data = value;
                newNode->left = newNode->right = NULL;
                return newNode;
            }
        
            if (value < root->data) {
                root->left = insert(root->left, value);
            } else if (value > root->data) {
                root->right = insert(root->right, value);
            }
        
            return root;
        }
        
        struct TreeNode* deleteNode(struct TreeNode* root, int key) {
            if (root == NULL) {
                return root;
            }
        
            if (key < root->data) {
                root->left = deleteNode(root->left, key);
            } else if (key > root->data) {
                root->right = deleteNode(root->right, key);
            } else {
            
                if (root->left == NULL) {
                    struct TreeNode* temp = root->right;
                    free(root);
                    return temp;
                } else if (root->right == NULL) {
                    struct TreeNode* temp = root->left;
                    free(root);
                    return temp;
                }
        
                struct TreeNode* temp = findMin(root->right);
        
                root->data = temp->data;
        
                root->right = deleteNode(root->right, temp->data);
            }
        
            return root;
        }
        
        struct TreeNode* search(struct TreeNode* root, int key) {
            if (root == NULL || root->data == key) {
                return root;
            }
        
            if (key < root->data) {
                return search(root->left, key);
            } else {
                return search(root->right, key);
            }
        }
        
        void preorder(struct TreeNode* root) {
            if (root != NULL) {
                printf("%d ", root->data);
                preorder(root->left);
                preorder(root->right);
            }
        }
        
        
        void inorder(struct TreeNode* root) {
            if (root != NULL) {
                inorder(root->left);
                printf("%d ", root->data);
                inorder(root->right);
            }
        }
        
        void postorder(struct TreeNode* root) {
            if (root != NULL) {
                postorder(root->left);
                postorder(root->right);
                printf("%d ", root->data);
            }
        }
        
        struct TreeNode* findMin(struct TreeNode* root) {
            struct TreeNode* current = root;
            while (current->left != NULL) {
                current = current->left;
            }
            return current;
        }
        
                
        output
        
        Binary Search Tree Operations
        1. Insert
        2. Delete
        3. Search
        4. Preorder Traversal
        5. Inorder Traversal
        6. Postorder Traversal
        7. Find Minimum Element
        8. Exit
        Enter your choice: 1
        Enter the value to insert: 3
        
        Binary Search Tree Operations
        1. Insert
        2. Delete
        3. Search
        4. Preorder Traversal
        5. Inorder Traversal
        6. Postorder Traversal
        7. Find Minimum Element
        8. Exit
        Enter your choice: 1
        Enter the value to insert: 5
        
        Binary Search Tree Operations
        1. Insert
        2. Delete
        3. Search
        4. Preorder Traversal
        5. Inorder Traversal
        6. Postorder Traversal
        7. Find Minimum Element
        8. Exit
        Enter your choice: 1
        Enter the value to insert: 3
        
        Binary Search Tree Operations
        1. Insert
        2. Delete
        3. Search
        4. Preorder Traversal
        5. Inorder Traversal
        6. Postorder Traversal
        7. Find Minimum Element
        8. Exit
        Enter your choice: 1
        Enter the value to insert: 4
        
        Binary Search Tree Operations
        1. Insert
        2. Delete
        3. Search
        4. Preorder Traversal
        5. Inorder Traversal
        6. Postorder Traversal
        7. Find Minimum Element
        8. Exit
        Enter your choice: 1
        Enter the value to insert: 7
        
        Binary Search Tree Operations
        1. Insert
        2. Delete
        3. Search
        4. Preorder Traversal
        5. Inorder Traversal
        6. Postorder Traversal
        7. Find Minimum Element
        8. Exit
        Enter your choice: 1
        Enter the value to insert: 6
        
        Binary Search Tree Operations
        1. Insert
        2. Delete
        3. Search
        4. Preorder Traversal
        5. Inorder Traversal
        6. Postorder Traversal
        7. Find Minimum Element
        8. Exit
        Enter your choice: 2
        Enter the key to delete: 3
        
        Binary Search Tree Operations
        1. Insert
        2. Delete
        3. Search
        4. Preorder Traversal
        5. Inorder Traversal
        6. Postorder Traversal
        7. Find Minimum Element
        8. Exit
        Enter your choice: 3
        Enter the key to search: 4
        4 is present in the tree.
        
        Binary Search Tree Operations
        1. Insert
        2. Delete
        3. Search
        4. Preorder Traversal
        5. Inorder Traversal
        6. Postorder Traversal
        7. Find Minimum Element
        8. Exit
        Enter your choice: 4
        Preorder Traversal: 5 4 7 6
        
        Binary Search Tree Operations
        1. Insert
        2. Delete
        3. Search
        4. Preorder Traversal
        5. Inorder Traversal
        6. Postorder Traversal
        7. Find Minimum Element
        8. Exit
        Enter your choice: 5
        Inorder Traversal: 4 5 6 7
        
        Binary Search Tree Operations
        1. Insert
        2. Delete
        3. Search
        4. Preorder Traversal
        5. Inorder Traversal
        6. Postorder Traversal
        7. Find Minimum Element
        8. Exit
        Enter your choice: 6
        Postorder Traversal: 4 6 7 5
        
        Binary Search Tree Operations
        1. Insert
        2. Delete
        3. Search
        4. Preorder Traversal
        5. Inorder Traversal
        6. Postorder Traversal
        7. Find Minimum Element
        8. Exit
        Enter your choice: 7
        Minimum Element: 4
        
        Binary Search Tree Operations
        1. Insert
        2. Delete
        3. Search
        4. Preorder Traversal
        5. Inorder Traversal
        6. Postorder Traversal
        7. Find Minimum Element
        8. Exit
        Enter your choice: 8
        Exiting the program.
    </pre>
</body>
</html>